[
  {
    "objectID": "posts/Revelando los Sentimientos Guatemaltecos/index.html",
    "href": "posts/Revelando los Sentimientos Guatemaltecos/index.html",
    "title": "Revelando los sentimientos guatemaltecos",
    "section": "",
    "text": "Con las elecciones presidenciales a menos de un mes de distancia, la importancia de comprender la voz del público no puede subestimarse. A través del uso de técnicas avanzadas, esta entrada busca no solo descubrir patrones en el sentimiento público, sino también demostrar cómo la nueva generación de modelos de lenguaje pueden emplearse para ofrecer perspectivas únicas y valiosas en la dinámica social y política de los países. Específicamente, utilizaremos dos poderosos recursos para llevar a cabo este análisis: la API de Twitter y la API de OpenAI.\n\nPrimero, descargaremos tweets que mencionan a los cinco candidatos que lideraban la encuesta de Prensa Libre publicada a principios de mayo desde la Twitter API V2 utilizando Python.\nEstos tweets, entonces, servirán como nuestro conjunto de datos base para extraer características utilizando la API de OpenAI y su modelo de lenguaje GPT-3.5-turbo, empleando una técnica llamada zero-shot feature extraction.\nPor último, terminaremos realizando una breve exploración de los resultados utilizando R, mi herramienta favorita cuando se trata de procedimientos estadísticos y de análisis de datos.\n\nA lo largo del blog, explicaremos cómo funcionan estas APIs, cómo utilizarlas implementando clases en Python lo suficientemente robustas como para lidiar con sus errores y excepciones, y cómo estos resultados se pueden utilizar para realizar un análisis profundo y significativo.\nDesde hace varios años, la intersección entre las ciencias de la computación y las ciencias sociales se ha transformado en uno de mis temas favoritos. Es verdaderamente emocionante darse cuenta de que nos encontramos en un momento único, en el cual es posible emplear tecnologías de vanguardia para obtener insights de eventos significativos. Quizás es más emocionante aún considerar que este tipo de análisis habría sido prácticamente imposible de llevar a cabo hace solo cinco años. ¿Lista? ¿Listo?"
  },
  {
    "objectID": "posts/Revelando los Sentimientos Guatemaltecos/index.html#extracción-de-tweets-con-tweepy",
    "href": "posts/Revelando los Sentimientos Guatemaltecos/index.html#extracción-de-tweets-con-tweepy",
    "title": "Revelando los sentimientos guatemaltecos",
    "section": "2 Extracción de tweets con Tweepy",
    "text": "2 Extracción de tweets con Tweepy\nOkay. Cartas sobre la mesa. Implementar estos programas ha conllevado bastante de mi tiempo libre en las últimas semanas; estoy seguro de que leer todos los detalles sobre estas implementaciones también requeriría de una cantidad de tiempo considerable, por lo que en esta y la siguiente sección únicamente haremos un repaso por los puntos más importantes1.1 Para los lectores más interesados he publicado este repositorio en el es posible encontrar todos los programas y módulos utilizados para generar estos resultados. Las clases y sus métodos fueron debidamente documentados, pero siéntete libre de contactarme si te gustaría saber más sobre los detalles de estas implementaciones.\n\nEnviando requests hacia la API\nLa estructura del repositorio es extremadamente sencilla y el diseño de las clases se adhiere al single-responsibility principle. El directorio modules contiene las clases encargadas de comunicarse con las APIs, mientras que los programas download_tweets.py y extract_features.py se encargan de descargar la información en batches. En el caso del procedimiento de extracción de tweets, el módulo twitter_request.py contiene a la clase TwitterRequest, responsable de comunicarse con la Twitter API V2 siguiendo los siguientes pasos:\n\nConsultar el endpoint GET_2_tweets_search_recent de la API utilizando al método search_recent_tweets para extraer los tweets que necesitamos.\nProcesar la respuesta de la API en formato JSON, conviertiéndola primero en un DataFrame.\nSeparar a ese DataFrame en dos: Uno que contenga información de los tweets y otro que contenga información de los usuarios que realizaron dichas publicaciones.\nPreprocesar ambos DataFrames para estandarizar los nombres de las columnas y cambiar las columnas que contienen fechas a un formato más conveniente.\n\nEn esta clase, el método más importante es make_request. Este método está decorado con @backoff.on_exception una forma increíblemente conveniente de hacer exponential backoff en el momento en el que se produzca un error por generar demasiados requests o una excepción producto de un timeout entre nuestro cliente y el servidor. En cualquiera de estos casos, la función esperará un tiempo exponencialmente creciente antes de volver a intentarlo y únicamente hará un máximo de 5 intentos.\n\nimport tweepy\nimport backoff\nimport requests\nfrom modules import setup_logger\n\n@backoff.on_exception(\n        backoff.expo, \n        (tweepy.errors.TooManyRequests, requests.exceptions.ReadTimeout),\n        max_tries=5\n    )\ndef make_request(self) -> \"TwitterRequest\":\n    self.query = f\"{self.query} -is:retweet -is:reply\"\n    self.logger.info(\"Making request with query: %s\", self.query)\n\n    try:\n        self.tweets = client.search_recent_tweets(\n            query = self.query,\n            start_time = self.start_time,\n            end_time = self.end_time,\n            max_results = self.max_results,\n            tweet_fields = [\n                \"id\", \"author_id\", \"created_at\", \"text\", \n                \"public_metrics\", \"possibly_sensitive\", \"lang\"\n            ],\n            user_fields = [\n                \"id\", \"username\", \"name\", \"location\", \"created_at\", \"description\", \n                \"profile_image_url\", \"verified\", \"public_metrics\"\n            ],\n            expansions = [\n                \"author_id\", \"referenced_tweets.id\"\n            ]\n        )\n        \n        if self.tweets is None or self.tweets.data is None:\n            self.logger.error(\"No tweets returned from request\")\n            return self\n          \n    except Exception as e: \n        self.logger.error(\"Exception occurred\", exc_info=True)\n        raise \n\n    self.logger.info(\"Request completed successfully.\")\n    return self\n\nEl mismo método define el query que se llevará a cabo, que en nuestro caso es un string con el nombre del candidato mencionado en los tweets, pero instruimos a la API para que no devuelva tweets que sean retweets o respuestas (f\"{self.query} -is:retweet -is:reply\"). En la solicitud, se incluyen campos específicos de los tweets y del usuario que los publicó. Por ejemplo, del tweet se solicita el ID, el autor, la fecha de creación, el texto, las métricas como cantidad de retweets, likes o respuestas, así como si la publicación tienen contenido sensible y cuál es su idioma. Del usuario solicitamos el ID, el nombre de usuario, el nombre, la ubicación, la fecha de creación del perfil, la descripción, la imagen de perfil, sus métricas públicas y si su perfil está verificado o no2.2 Aunque mis procedimientos extrajeron toda esta información para más de 5,000 tweets que fueron publicados por múltiples usuarios durante las últimas dos semanas, el Developer Agreement and Policy de Twitter me prohibe publicar la totalidad de la información. Sin embargo, he publicado un dataset reducido que contiene 1,420 tweets con sus respectivas métricas públicas y las características extraídas utilizando al modelo de lenguaje.\nSi la solicitud es exitosa y se obtiene cierta cantidad de tweets que son almacenados en el atributo self.tweets. Si no se obtiene ningún tweet, se registra un error en el log. Si ocurre alguna otra excepción durante la solicitud, también se registra en el log y es levantada para que pueda ser manejada por el decorador encargado de hacer exponential backoff. Por último, si la solicitud se completó con éxito, registramos este hecho en el log y retornamos al objeto self, para darnos la posibilidad de hacer method chaining.\nDe esta forma, utilizar la clase TwitterRequest requiere únicamente de inicializarla con los parámetros query, start_time, end_time y max_results. Like so:\n\nfrom datetime import datetime\nfrom modules import TwitterRequest\n\ntweets, users = (\n  TwitterRequest(\n      query='zury rios',\n      start_time=datetime(2023, 5, 20, 15, 00),\n      end_time=datetime(2023, 5, 21, 15, 00),\n      max_results=10\n  )\n  .make_request()\n  .tweets_to_dataframe()\n  .users_to_dataframe()\n  .segregate_dataframe()\n  .preprocess_data(\n      tweets_prefix='tw_',\n      users_prefix='us_'\n  )\n)\n\n\n\nDescargando tweets en batches\nTenemos una forma de comunicarnos con la API de Twitter, pedirle los datos que nos interesan y preprocesarlos para que estén listos para el resto del pipeline. Sin embargo, Twitter no nos va a hacer la vida fácil. Su API únicamente permite descargar tweets publicados en los últimos 7 días en batches de 60 tweets como máximo en un espacio de 15 minutos.33 Overprotective much?\nNi modo. El programa download_tweets.py esta diseñado para lidiar con las restricciones de la API de Twitter. El método download_tweets es un componente de la clase DownloadTweets. En resumen, este método descarga tweets y usuarios (utilizando el método get_batch, que es un wrapper para la clase TwitterRequest). Para cada candidato y rango de fechas, se invoca el método get_batch para obtener los tweets y usuarios, que se recopilan y se concatenan en dos atributos: self.tweets y self.users. Finalmente, el método devuelve estos dos DataFrames que contienen todos los tweets y usuarios recolectados.\n\ndef download_tweets(self) -> Tuple[pd.DataFrame, pd.DataFrame]:\n    self.generate_dates()\n    logger.info(f\"Generated {len(self.dates)} date pairs for tweet downloads.\")\n\n    # Collect tweets and users for each candidate.\n    tweets_collector, users_collector = [], []\n    for candidate in self.candidates:\n\n        # Collect tweets and users for each date.\n        dates_tweets_collector, dates_users_collector = [], []\n        for start_date, end_date in self.dates:\n\n            tweets, users = self.get_batch(candidate, start_date, end_date)\n            dates_tweets_collector.append(tweets)\n            dates_users_collector.append(users)\n\n        tweets_collector.append(pd.concat(dates_tweets_collector))\n        users_collector.append(pd.concat(dates_users_collector))\n\n    self.tweets = pd.concat(tweets_collector, axis=0, ignore_index=True)\n    self.users = pd.concat(users_collector, axis=0, ignore_index=True)\n\n    logger.info(\n      f\"Downloaded a total of {len(self.tweets)} tweets and {len(self.users)} users.\"\n    )\n    return self.tweets, self.users"
  },
  {
    "objectID": "posts/Revelando los Sentimientos Guatemaltecos/index.html#zero-shot-feature-extraccion-con-gpt-3.5",
    "href": "posts/Revelando los Sentimientos Guatemaltecos/index.html#zero-shot-feature-extraccion-con-gpt-3.5",
    "title": "Revelando los sentimientos guatemaltecos",
    "section": "3 Zero-shot feature extraccion con GPT-3.5",
    "text": "3 Zero-shot feature extraccion con GPT-3.5\nAhora viene una de mis partes favoritas en este proceso. Vamos a usar a GPT-3.5 para generar nuevas features basadas en los tweets que hemos extraído. ¿Cómo? Much in the same way we downloaded tweets, usando una clase llamada OpenAIRequest (que se encargará de comunicarse con la API) y otra, llamada FeatureExtraction, que nos servirá para iterar en las filas del DataFrame que contiene las publicaciones de los usuarios de Twitter.\n\nEnviando requests hacia la API\nEl primer método relevante en la clase OpenAIRequest es make_request. De manera similar al método con el mismo nombre en el procedimiento de extracción de tweets, esta función estática está decorada con backoff.on_exception para poder lidiar con errores en el caso de un timeout o por sobrepasar los límites de uso de la API. En el caso del modelo gpt-3.5-turbo, podemos realizar una cantidad de 3,500 requests por minuto o enviar al endpoint un máximo 90,000 tokens en la misma cantidad de tiempo, lo que pase primero.\nComo veremos más adelante, el prompt con el que instruiremos al modelo tiene, en promedio, 600 tokens.4 En teoría, esto quiere decir que (basándonos en el límite de TPM) podemos enviar 150 requests cada 60 segundos. En la práctica, though, los tiempos de inferencia de los modelos de lenguaje son bastante altos. En nuestro caso, el tiempo de procesamiento por cada tweet fue de aproximadamente 15 segundos, así que extraer características para 1,420 tweets fue un proceso que tomó 6 horas, give or take.4 OpenAI pone a nuestra disposición este tokenizer, una herramienta que nos permite hacer un recuento de la cantidad de tokens en nuestros prompts. En lo personal, me sirve muchísimo para calcular los costos de procesamiento y para asegurarme de que mis prompts sean eficientes en términos de longitud.\nLos parámetros que acepta make_request son nuestro prompt, la especificación del modelo que queremos utilizar y temperature, un parámetro del modelo de lenguaje que puede ser un número entre 0 y 1. La temperatura controla el grado de aleatoriedad en las respuestas del modelo. Un valor de temperature más alto (cerca de 1) hace que el modelo genere respuestas más diversas y creativas, mientras que un valor más bajo (cerca de 0) hace que las respuestas sean más determinísticas o consistentes.55 Los transformers, como GPT, son en sí mismos arquitecturas de redes neuronales determinísticas (es decir, generan la misma salida para una entrada específica). Sin embargo, se introduce aleatoriedad durante la generación de texto a través del muestreo de diferentes secuencias de palabras de acuerdo a las probabilidades de salida del modelo. En general, cuando usamos al modelo como un paso de procesamiento dentro de nuestros pipelines, queremos que cada respuesta sea lo más consistente posible para reducir las posibilidades de introducir bugs en nuestro sistema.\n\n@staticmethod\n@backoff.on_exception(\n    backoff.expo, \n    (openai.error.RateLimitError, requests.exceptions.ReadTimeout),\n    max_tries=5\n)\ndef make_request(prompt: str, model: str = \"gpt-3.5-turbo\", temperature: float = 0) -> str: \n    messages = [{\"role\": \"user\", \"content\": prompt}]\n    response = openai.ChatCompletion.create(\n        model=model,\n        messages=messages,\n        temperature=temperature, \n    )\n    return response.choices[0].message[\"content\"]\n\nEl siguiente método relevante en la clase OpenAIRequest es extract_features. En este método, definimos el prompt que será utilizado para instruir al modelo de lenguaje. Este prompt es parametrizado a través de una f string, para permitirnos cambiar fácilmente la entrada según sea necesario.\nUna vez definido el prompt, realizamos la consulta a la API de OpenAI utilizando el método make_request. Si la respuesta obtenida es nula o inválida, registramos un error en el log y retornamos None. Además, para robustecer al procedimiento y manejar posibles excepciones durante la solicitud a la API, hemos envuelto este segmento de código dentro de un bloque Try Except. Si todo sale según lo planeado y obtenemos una respuesta válida, la misma es cargada como un diccionario JSON y finalmente retornada por el método extract_features.\n\ndef extract_features(self, prefix: str) -> dict:\n    prompt = f\"\"\" (...) \"\"\"\n    \n    try:\n        response = OpenAIRequest.make_request(prompt)\n        if response is None:\n            self.logger.error(\"Received invalid response from OpenAI\")\n            return None\n        response = json.loads(response)\n    except Exception as e:\n        self.logger.error(f\"Exception during API request: {e}\")\n        return None\n\n    return response\n\n\n\nPrompt engineering\nTengo que confesar algo. Hace unas semanas leí en una publicación de LinkedIn una frase que decía algo así como: “Calling ‘prompt engineering’ the action of using ChatGPT today is like calling ‘search engineering’ to googling something in the early 2000s”. Y la confesión es que… pienso que es verdad.66 Por cierto, ya que estamos confesando cosas. La idea de esta entrada surgió porque hace poco más de un mes vi los videos del curso de deeplearning.ai llamado ChatGPT Prompt Engineering for Developers. Es un curso extremadamente corto que tiene información útil acerca de los casos de uso del modelo desde una perspectiva programática. Si estás leyendo este blog, chances are you’re also gonna like this.\nNontheless, considero que cuando vamos un paso más allá y utilizamos estos modelos desde los endpoints que OpenAI pone a nuestra disposición, el hype que existe hacia el término está un poco más justificado. Principalmente porque, aunque redactamos la instrucción en lenguaje natural, el procedimiento recuerda mucho a definir una serie de pasos en cualquier lenguaje de programación.\nPara nuestros fines, este prompt dio buenos resultados:\n\n\n\n\n\n\n\n\nprompt = f\"\"\"\nEl siguiente es un tweet que menciona a un candidato presidencial dentro de la contienda electoral 2023 en Guatemala. \n\nPor favor, clasifícalo de acuerdo a las siguientes categorías:\n\nValencia (sentimiento general): [positivo, negativo, neutro, otro]\nEmoción (emoción principal expresada): [felicidad, tristeza, enojo, miedo, sorpresa, disgusto, otro]\nPostura (actitud hacia el tema): [aprobación, desaprobación, esperanza, desilusión, indiferencia, confianza, desconfianza, otro]\nTono (forma de expresarse): [agresivo, pasivo, asertivo, escéptico, irónico, humorístico, informativo, serio, inspirador, otro]\n\nAdemás, evalúalo utilizando una escala continua con rango de 0 a 1 en las siguientes dimensiones:\n\nAmabilidad (nivel de cortesía): [0.0 - 1.0]\nLegibilidad (facilidad de lectura): [0.0 - 1.0]\nControversialidad (potencial para generar desacuerdo): [0.0 - 1.0]\nInformatividad (cantidad de información relevante y fundamentada): [0.0 - 1.0]\n\nFormatea tu respuesta como un diccionario de Python con las siguientes llaves:\n\n[valencia, emocion, postura, tono, amabilidad, legibilidad, controversialidad, informatividad]\n\nTweet: '''{self.tweet}'''\n\"\"\"\n\n\n\n\n\n\n\nZero-shot feature extraction\nEstamos muy cerca de obtener los resultados que buscamos. Hasta el momento, los módulos que hemos implementado nos permiten enviar consultas hacia las APIs de Twitter y OpenAI, así como descargar batches de tweets que mencionan a los cinco candidatos que encabezaban la encuesta de Prensa Libre, publicada a inicios de mayo. Solo nos falta una forma procesar estos tweets para extraer variables que nos permitan analizarlos a una mayor profundidad. Enter extract_features.py, un programa en el que la clase OpenAIRequest es instanciada dentro de la clase FeatureExtraction.\nEn el constructor de la clase se inicializan las rutas a dos archivos: df_path que es la ruta al archivo csv de entrada que contiene los tweets, y results_df_path que es la ruta al archivo csv de salida donde se almacenarán las características extraídas.\nEl método principal de esta clase es extract_features. Este método primero carga los tweets del archivo csv de entrada y elimina los duplicados. Luego intenta cargar las características ya extraídas del archivo csv de salida. Si este archivo no existe, se inicializa un nuevo DataFrame vacío. El método luego determina qué tweets aún no han sido procesados comparando los tweets en los dos DataFrames y seleccionando aquellos que solo están en el DataFrame de entrada.\n\ndef extract_features(self):\n    df = pd.read_csv(self.df_path)\n    df = df.drop_duplicates(subset=['tw_texto'], keep='first')\n\n    try:\n        df_results = pd.read_csv(self.results_df_path)\n        df_results = df_results.drop_duplicates(subset=['tw_texto'], keep='first')\n    except FileNotFoundError:\n        df_results = pd.DataFrame()\n\n    df_to_process = df[~df['tw_texto'].isin(df_results['tw_texto'])]\n    df_to_process = df_to_process.dropna()\n\n    for index, row in df_to_process.iterrows():\n        tweet = row['tw_texto']\n        response = (\n            OpenAIRequest(tweet)\n            .preprocess_text()\n            .extract_features(prefix='tw_')\n        )\n        df_result = pd.DataFrame([response], index=[index])\n        df_results = pd.concat([df_results, df_result])\n        df_results.to_csv(self.results_df_path, index=False)\n\nA continuación, se procesa cada tweet que aún no ha sido procesado. Para cada uno de ellos, se realiza una solicitud a la API de OpenAI para realizar el procedimiento de feature extraction utilizando al modelo gpt-3.5-turbo. Las características extraídas se añaden al DataFrame de resultados, junto con el tweet original y un tag para identificar a qué candidato se refiere cada publicación.\nFinalmente, después de procesar cada tweet, el DataFrame de resultados se guarda en el archivo csv de salida. Esto se hace después de cada tweet para evitar la pérdida de información en caso de que se produzca un error durante el procesamiento."
  },
  {
    "objectID": "posts/Revelando los Sentimientos Guatemaltecos/index.html#análisis-de-la-opinión-pública",
    "href": "posts/Revelando los Sentimientos Guatemaltecos/index.html#análisis-de-la-opinión-pública",
    "title": "Revelando los sentimientos guatemaltecos",
    "section": "4 Análisis de la opinión pública",
    "text": "4 Análisis de la opinión pública\nCool. Todos los procedimientos anteriores nos llevan a esta situación en la que tenemos un conjunto de datos listo para ser analizado. Como mencioné en algún punto de esta entrada, he publicado este dataset en un repositorio de GitHub. By all means, síentete libre de descargarlo y hacer tu propio análisis exploratorio de datos. Si lo haces, me encantaría conocer tus descubrimientos. El dataset luce más o menos así:\n\n\n\n\n \n  \n    fecha \n    tweet \n    candidato \n    retweets \n    replies \n    likes \n    quotes \n    impresiones \n    valencia \n    emocion \n    postura \n    tono \n    amabilidad \n    legibilidad \n    controversialidad \n    informatividad \n    sensitivo \n  \n \n\n  \n    2023-05-15 \n    Sandra Torres es capaz de todo por mantener el poder. Recibió dinero sucio, se vendió con Alejandro Giammattei para evitar que cancelaran su partido, incluyó a señalados de corrupción y participó de una red de captación de fondos ilícitos. https://t.co/4J2pX1BSx6 \n    sandra torres \n    0 \n    1 \n    0 \n    0 \n    335 \n    negativo \n    enojo \n    desaprobación \n    agresivo \n    0.2 \n    0.8 \n    0.9 \n    0.9 \n    FALSE \n  \n  \n    2023-05-15 \n    Sandra Torres anda regalando zapatos a cambio de votos 😡 esto tiene que parar https://t.co/8OltsAmeiq \n    sandra torres \n    0 \n    0 \n    5 \n    0 \n    420 \n    negativo \n    enojo \n    desaprobación \n    agresivo \n    0.2 \n    0.9 \n    0.8 \n    0.8 \n    FALSE \n  \n  \n    2023-05-15 \n    Y en donde están los ladrones como Sandra torres. Baldizon. Los arzu. Portillo. Los ríos montt. Los jimmy morales. Los Giammattei y tantos diputados. Que le han robado millones  al pueblo de guatemala. https://t.co/KVngH40GF9 \n    sandra torres \n    0 \n    0 \n    0 \n    0 \n    234 \n    negativo \n    enojo \n    desaprobación \n    agresivo \n    0.2 \n    0.8 \n    0.7 \n    0.9 \n    FALSE \n  \n  \n    2023-05-15 \n    #AlertaPopulista 🚨\n\n¿Sandra Torres, sabe cuáles son derechos humanos?\n\nTe presentamos el episodio número 5 de nuestra sección \"El Populista de la Semana\" con @PalmieriWaelti\n\n#EleccionesGuatemala #Elecciones2023 #Guatemala #EleccionesGT #Populistas #Facts #Noticias https://t.co/MeoijdOE12 \n    sandra torres \n    6 \n    9 \n    17 \n    1 \n    3186 \n    negativo \n    enojo \n    desaprobación \n    agresivo \n    0.2 \n    0.9 \n    0.8 \n    0.8 \n    FALSE \n  \n  \n    2023-05-15 \n    La CC dejó en firme la inscripción del binomio presidencial de la UNE conformado por Sandra Torres y Romeo Estuardo Guerra Lemus. 🔽 https://t.co/yG7AEiXV1Y \n    sandra torres \n    0 \n    0 \n    0 \n    0 \n    129 \n    neutro \n    otro \n    información \n    informativo \n    0.8 \n    1.0 \n    0.2 \n    1.0 \n    FALSE \n  \n  \n    2023-05-15 \n    🤔🤣\n¿La hija de Sandra Torres hablando de izquierdosos?\n¿WTF?!!! https://t.co/Jd4ZaiQ9K3 https://t.co/qk4vZo50aD \n    sandra torres \n    0 \n    0 \n    2 \n    0 \n    180 \n    negativo \n    enojo \n    desaprobación \n    irónico \n    0.2 \n    1.0 \n    0.8 \n    0.6 \n    TRUE"
  },
  {
    "objectID": "posts/Revelando los Sentimientos Guatemaltecos/index.html#conclusiones",
    "href": "posts/Revelando los Sentimientos Guatemaltecos/index.html#conclusiones",
    "title": "Revelando los sentimientos guatemaltecos",
    "section": "5 Conclusiones",
    "text": "5 Conclusiones\n\nLos tiempos de inferencia son altos, así que los límites de la API de OpenAI son bastante bondadosos."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Data science y machine learning",
    "section": "",
    "text": "Revelando los sentimientos guatemaltecos\n\n\nExtracción zero-shot de variables para tweets acerca de las elecciones presidenciales 2023 usando GPT-3.5\n\n\n\n\nNatural language processing\n\n\nObject-oriented programming\n\n\nData engineering\n\n\n\n\n\n\n\n\n\n\n\n31 may 2023\n\n\n17 minutos\n\n\n\n\n\n\nNo hay resultados"
  }
]